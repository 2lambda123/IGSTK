#include "igstkTrackerConfiguration.h"
#include "igstkTrackerController.h"
#include "igstkPolarisVicraConfigurationXMLFileReader.h"
#include "igstkPolarisSpectraConfigurationXMLFileReader.h"
#include "igstkPolarisHybridConfigurationXMLFileReader.h"
#include "igstkAuroraConfigurationXMLFileReader.h"
#include "igstkMicronConfigurationXMLFileReader.h"
#include "igstkOIGTLinkTrackerConfigurationFileReader.h"
#include "igstkTransformObserver.h"

/**
 * Class that observers both read success, 
 * igstk::TrackerConfigurationFileReader::ReadSuccessEventand 
 * and read failure,
 * igstk::TrackerConfigurationFileReader::ReadFailureEvent
 * events generated by the TrackerConfigurationFileReader class.
 */

class ReadFailSuccessObserver : public ::itk::Command
{
public:
  typedef  ReadFailSuccessObserver    Self;
  typedef  ::itk::Command             Superclass;
  typedef  ::itk::SmartPointer<Self>  Pointer;
  itkNewMacro( Self );
protected:
  ReadFailSuccessObserver() : m_GotFailure( false ), m_GotSuccess( false ) {}
  ~ReadFailSuccessObserver() {}
public:
  void Execute(itk::Object *caller, const itk::EventObject & event)
  {
    const itk::Object * constCaller = caller;
    this->Execute( constCaller, event );
  }
  void Execute(const itk::Object *caller, const itk::EventObject & event)
  {
  if( const igstk::OIGTLinkTrackerConfigurationFileReader::ReadSuccessEvent *rse = 
      dynamic_cast<const igstk::OIGTLinkTrackerConfigurationFileReader::ReadSuccessEvent *>( &event) )
      m_GotSuccess = true;
  else if( const igstk::OIGTLinkTrackerConfigurationFileReader::ReadFailureEvent *rfe = 
           dynamic_cast<const igstk::OIGTLinkTrackerConfigurationFileReader::ReadFailureEvent *>( &event) )
    {
      m_GotFailure = true;
      m_FailureMessage = rfe->Get();
    }
  }
  bool GotSuccess() {return this->m_GotSuccess;}
  bool GotFailure() {return this->m_GotFailure;}
  void Reset() 
  { 
    this->m_GotSuccess = false; 
    this->m_GotFailure = false;
    this->m_FailureMessage.clear();
  }
  std::string GetFailureMessage() const
  {
    return m_FailureMessage;
  }
private:
  std::string m_FailureMessage;
  bool m_GotSuccess;
  bool m_GotFailure;
};


/**
 * Observer for the event generated by 
 * TrackerConfigurationFileReader->RequestGetData() method.
 */
igstkObserverMacro( OIGTLinkTrackerConfiguration, 
                   igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataEvent, 
                   igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataPointerType )

/**
 * Observer for the TrackerController->RequestInitialize() failure.
 */
igstkObserverMacro( InitializeError, 
                   igstk::TrackerController::InitializeErrorEvent, 
                   std::string )


/**
 * Observer for the TrackerController->RequestGetNonReferenceToolList() 
 */
igstkObserverMacro( ToolList, 
                   igstk::TrackerController::RequestToolsEvent, 
                   igstk::TrackerController::ToolContainerType )

/**
 * Observer for the TrackerController->RequestGetTool() and  
 * TrackerController->RequestGetReferenceTool()
 */
igstkObserverMacro( Tool, 
                   igstk::TrackerController::RequestToolEvent, 
                   igstk::TrackerController::ToolEntryType )

/**
 * This class observes the TrackerToolTransformUpdateEvent for a specific tool.
 * It checks that the event is for the relevant tool and then gets the tool's
 * transform to its parent and prints it out.
 */
class ToolUpdatedObserver : public ::itk::Command
{
public:
  typedef  ToolUpdatedObserver    Self;
  typedef  ::itk::Command             Superclass;
  typedef  ::itk::SmartPointer<Self>  Pointer;
  itkNewMacro( Self );
protected:
  ToolUpdatedObserver() {
    this->m_TransformObserver = igstk::TransformObserver::New();
  }

  ~ToolUpdatedObserver() {}

public:
  void Initialize( igstk::TrackerTool::Pointer trackerTool,
                   const std::string &hostName, 
                   unsigned int portNumber )
  {
    this->m_Tool = trackerTool;
    this->m_TransformObserver->ObserveTransformEventsFrom( this->m_Tool );
    this->m_HostName = hostName;
    this->m_PortNumber = portNumber;
  }

  void Execute(itk::Object *caller, const itk::EventObject & event)
  {
    const itk::Object * constCaller = caller;
    this->Execute( constCaller, event );
  }

  void Execute(const itk::Object *caller, const itk::EventObject & event)
  {               //do something only for the correct tool
    if( this->m_Tool.GetPointer() == caller )
    {               //the tool transform has been updated, get it
      if( dynamic_cast<const igstk::TrackerToolTransformUpdateEvent  *>( &event) )
      {                 //request to get the transform               
        this->m_Tool->RequestGetTransformToParent();
                       //check that we got it
        if ( this->m_TransformObserver->GotTransform() )
        {
          igstk::Transform transform = this->m_TransformObserver->GetTransform();
          igstk::Transform::VectorType t = transform.GetTranslation();
          igstk::Transform::VersorType r = transform.GetRotation();
          std::cout<<"Destination: "<<this->m_HostName<<":"<<this->m_PortNumber;
          std::cout<<"\nt:"<<t[0]<<"\t"<<t[1]<<"\t"<<t[2]<<"\n";
          std::cout<<"r:"<<r.GetX()<<"\t"<<r.GetY()<<"\t"<<r.GetZ()<<"\t"<<r.GetW()<<"\n";
        }
      }
    }
  }

private:
  std::string m_HostName;
  unsigned int m_PortNumber;  
  igstk::TransformObserver::Pointer m_TransformObserver; 
  igstk::TrackerTool::Pointer  m_Tool;
};


int main( int argc, char *argv[] )
{
  const unsigned int NUM_TRACKER_TYPES = 5;
  char * trackerTypes[NUM_TRACKER_TYPES]; 
  enum { PolarisVicra, PolarisSpectra, PolarisHybrid, Aurora, Micron };
  trackerTypes[PolarisVicra] = "Polaris Vicra";
  trackerTypes[PolarisSpectra] = "Polaris Spectra";
  trackerTypes[PolarisHybrid] = "Polaris Hybrid";
  trackerTypes[Aurora] = "Aurora";
  trackerTypes[Micron] = "Micron";

  if( argc!=3 )
  {
    std::cerr<<"Usage: "<<argv[0]<<" tracker_type ";
    std::cerr<<"tracker_xml_configuration_file.\n";
    std::cerr<<"Tracker types:\n";
    for( int i=0; i<NUM_TRACKER_TYPES; i++ )
      std::cerr<<"\t"<<i<<" == "<<trackerTypes[i]<<"\n";
    return EXIT_FAILURE;
  }

  igstk::OIGTLinkTrackerConfigurationFileReader::Pointer trackerConfigReader = 
    igstk::OIGTLinkTrackerConfigurationFileReader::New();

  igstk::TrackerConfigurationXMLFileReaderBase::Pointer 
    trackerCofigurationXMLReader;

             //I'm assuming I get an integer here, skipping the validation
  switch( atoi( argv[1] ) )
  {
    case PolarisVicra:
      trackerCofigurationXMLReader = 
        igstk::PolarisVicraConfigurationXMLFileReader::New();
      break;
    case PolarisSpectra:
      trackerCofigurationXMLReader = 
        igstk::PolarisSpectraConfigurationXMLFileReader::New();
      break;
    case PolarisHybrid:
      trackerCofigurationXMLReader = 
        igstk::PolarisHybridConfigurationXMLFileReader::New();
      break;
    case Aurora:
      trackerCofigurationXMLReader = 
        igstk::AuroraConfigurationXMLFileReader::New();
      break;
    case Micron:
      trackerCofigurationXMLReader = 
        igstk::MicronConfigurationXMLFileReader::New();
      break;
    default:
      std::cerr<<"Invalid tracker type. Valid types are:\n";
      for( int i=0; i<NUM_TRACKER_TYPES; i++ )
        std::cerr<<"\t"<<i<<" == "<<trackerTypes[i]<<"\n";
      return EXIT_FAILURE;
  }

             //setting the file name and reader always succeeds so I don't
             //observe the trackerConfigReader for their success events
  trackerConfigReader->RequestSetFileName( argv[2] );
  trackerConfigReader->RequestSetReader( trackerCofigurationXMLReader );  
  
                //need to observe if the request read succeeds or fails
                //there is a third option that the read is invalid, if the
                //file name or xml reader weren't set
  ReadFailSuccessObserver::Pointer rfso = ReadFailSuccessObserver::New();
  trackerConfigReader->AddObserver( igstk::OIGTLinkTrackerConfigurationFileReader::ReadSuccessEvent(),
                                    rfso );
  trackerConfigReader->AddObserver( igstk::OIGTLinkTrackerConfigurationFileReader::ReadFailureEvent(),
                                    rfso );
  trackerConfigReader->RequestRead();

  if( rfso->GotFailure() )
  {
    std::cerr<<rfso->GetFailureMessage()<<"\n";
    return EXIT_FAILURE;
  }
  if( !rfso->GotSuccess() )
  {
    std::cerr<<"Reading xml file did not succeed or fail, ";
    std::cerr<<"invoked in an inappropriate manner (prior to setting file name or xml reader).\n";
    return EXIT_FAILURE;
  }
                 //get the configuration data from the reader
  OIGTLinkTrackerConfigurationObserver::Pointer tco = 
    OIGTLinkTrackerConfigurationObserver::New();
  trackerConfigReader->AddObserver( 
    igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataEvent(),
    tco );
  trackerConfigReader->RequestGetData();
  
  if( !tco->GotOIGTLinkTrackerConfiguration() )
  {
    std::cerr<< "Did not get tracker configuration...\n";
    return EXIT_FAILURE;
  }

  igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataType 
    *oigtLinkTrackerConfiguration = tco->GetOIGTLinkTrackerConfiguration();
  
         //initialize the tracker controller, setup the observers and start tracking
  igstk::TrackerController::Pointer trackerController = 
    igstk::TrackerController::New();
  
  InitializeErrorObserver::Pointer ieo = 
    InitializeErrorObserver::New();
  trackerController->AddObserver( igstk::TrackerController::InitializeErrorEvent(),
                                  ieo );
  trackerController->RequestInitialize( oigtLinkTrackerConfiguration->m_TrackerConfiguration );
  if( ieo->GotInitializeError() )
  {
    std::cerr<<ieo->GetInitializeError()<<"\n";
    return EXIT_FAILURE;
  }
                //make sure we don't have a reference and setup the observers
  ToolObserver::Pointer requestReferenceToolObserver = 
    ToolObserver::New();
  trackerController->AddObserver( igstk::TrackerController::RequestToolEvent(),
                                  requestReferenceToolObserver );
  trackerController->RequestGetReferenceTool();
  if( requestReferenceToolObserver->GotTool() )
  {
    std::cerr<<"You have set a dynamic reference frame.\n";
    std::cerr<<"The intention of this program is to output transformation data";
    std::cerr<<" relative to the tracker, please do not set reference.\n";
    return EXIT_FAILURE;
  }

  ToolListObserver::Pointer requestNonReferenceToolsObserver = 
    ToolListObserver::New();
  trackerController->AddObserver( igstk::TrackerController::RequestToolsEvent(),
                                  requestNonReferenceToolsObserver );

  trackerController->RequestGetNonReferenceToolList();
  if( requestNonReferenceToolsObserver->GotToolList() )
  {
    igstk::TrackerController::ToolContainerType toolContainer = 
      requestNonReferenceToolsObserver->GetToolList();
    igstk::TrackerController::ToolContainerType::iterator toolNamesAndToolsIt;
    std::map<std::string, unsigned int>::iterator toolNamesAndPortsIt =
      oigtLinkTrackerConfiguration->m_ToolNamesAndPorts.begin(); 
    std::map<std::string, unsigned int>::iterator toolNamesAndPortsEnd =
      oigtLinkTrackerConfiguration->m_ToolNamesAndPorts.end(); 
    for(; toolNamesAndPortsIt!=toolNamesAndPortsEnd; toolNamesAndPortsIt++ )
    {
      toolNamesAndToolsIt = toolContainer.find( toolNamesAndPortsIt->first );   
      if( toolNamesAndToolsIt != toolContainer.end() )
      {
        ToolUpdatedObserver::Pointer updateObserver = 
          ToolUpdatedObserver::New();
        updateObserver->Initialize( toolNamesAndToolsIt->second,
                                    oigtLinkTrackerConfiguration->m_HostName, 
                                    toolNamesAndPortsIt->second );
        toolNamesAndToolsIt->second->AddObserver( igstk::TrackerToolTransformUpdateEvent(), 
                                                  updateObserver );
      }
    }
  }

  trackerController->RequestStartTracking();

            //how long does the program run [milliseconds]
  const double RUNNING_TIME = 15000; //15sec
  double endTime = igstk::RealTimeClock::GetTimeStamp() + RUNNING_TIME;

  while( igstk::RealTimeClock::GetTimeStamp() < endTime ) 
  {
    igstk::PulseGenerator::Sleep(10);
    igstk::PulseGenerator::CheckTimeouts();
  }

  return EXIT_SUCCESS;
}
