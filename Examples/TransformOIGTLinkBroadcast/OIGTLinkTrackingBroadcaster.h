#ifndef __OIGTLinkTrackingBroadcaster_h
#define __OIGTLinkTrackingBroadcaster_h

#include "igstkTrackerConfiguration.h"
#include "igstkTrackerController.h"
#include "igstkPolarisVicraConfigurationXMLFileReader.h"
#include "igstkPolarisSpectraConfigurationXMLFileReader.h"
#include "igstkPolarisHybridConfigurationXMLFileReader.h"
#include "igstkAuroraConfigurationXMLFileReader.h"
#include "igstkMicronConfigurationXMLFileReader.h"
#include "igstkOIGTLinkTrackerConfigurationFileReader.h"
#include "igstkTransformObserver.h"

// For sending tracking data to OpenIGTLink compatible server 
#include "igtlOSUtil.h"
#include "igtlPositionMessage.h"
#include "igtlClientSocket.h"

/**
 * \class This class performs broadcasting of tracking data using the OpenIGTLink
 * communication protocol. 
 *
 * The class is instantiated with the name of the xml file containing the 
 * tracker and OIGTLink information. The user can then start and stop the 
 * tracking.
 */
class OIGTLinkTrackingBroadcaster
{
public:

  /**
  * This class was created due to the need for platform independence. 
  * In windows the std::exception class has a constructor which has a string as
  * payload, sadly in linux/unix this constructor does not exist. 
  */
  class ExceptionWithMessage : public std::exception
  {
  public:
    ExceptionWithMessage (const std::string & str) throw()
    {
      this->m_Str = str;
    }
    virtual ~ExceptionWithMessage() throw () {} 

    virtual const char *what() const throw ()
    {
      return this->m_Str.c_str();
    }
  private:
    std::string m_Str;
  };

  OIGTLinkTrackingBroadcaster( std::string &trackerXMLConfigurationFileName ) 
    throw ( ExceptionWithMessage );

  ~OIGTLinkTrackingBroadcaster(){ }

  void StartTracking();

  void StopTracking();

private:

  /**
  * Observer for the event generated by 
  * TrackerConfigurationFileReader->RequestGetData() method.
  */
  igstkObserverMacro( OIGTLinkTrackerConfiguration, 
    igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataEvent, 
    igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataPointerType )

    /**
    * Observer for the TrackerController->RequestInitialize() failure.
    */
    igstkObserverMacro( InitializeError, 
    igstk::TrackerController::InitializeErrorEvent, 
    std::string )


    /**
    * Observer for the TrackerController->RequestStartTracking() failure.
    */
    igstkObserverMacro( StartTrackingError, 
    igstk::TrackerStartTrackingErrorEvent,
    std::string )

    /**
    * Observer for the TrackerController->RequestStopTracking() failure.
    */
    igstkObserverMacro( StopTrackingError, 
    igstk::TrackerStopTrackingErrorEvent,
    std::string )

    /**
    * Observer for the TrackerController->RequestGetNonReferenceToolList() 
    */
    igstkObserverMacro( ToolList, 
    igstk::TrackerController::RequestToolsEvent, 
    igstk::TrackerController::ToolContainerType )

    /**
    * Observer for the TrackerController->RequestGetTool() and  
    * TrackerController->RequestGetReferenceTool()
    */
    igstkObserverMacro( Tool, 
    igstk::TrackerController::RequestToolEvent, 
    igstk::TrackerController::ToolEntryType )

/**
 * This class observes the TrackerToolTransformUpdateEvent for a specific tool.
 * It checks that the event is for the relevant tool and then gets the tool's
 * transform w.r.t. the "world" coordinate system. The transform is then 
 * broadcasted to all destinations.
 */
  class ToolUpdatedObserver : public ::itk::Command
  {
  public:
    typedef  ToolUpdatedObserver    Self;
    typedef  ::itk::Command             Superclass;
    typedef  ::itk::SmartPointer<Self>  Pointer;
    itkNewMacro( Self );
  protected:
    ToolUpdatedObserver() {
      this->m_TransformObserver = igstk::TransformObserver::New();
      this->m_PositionMessage = igtl::PositionMessage::New();
    }

    ~ToolUpdatedObserver() {
      std::vector< igtl::ClientSocket::Pointer >::iterator it; 
      for (it = this->m_Sockets.begin(); it != this->m_Sockets.end(); ++it)
      {
        (*it)->CloseSocket();
        (*it)->Delete();
      }
      this->m_Sockets.clear();

      this->m_PositionMessage->Delete();
    }

  public:

    void Initialize( 
      const std::string toolName, 
      igstk::TrackerTool::Pointer trackerTool,
      igstk::SpatialObject::Pointer world,
      std::vector< std::pair<std::string, unsigned int> > & destinations)
    {
      this->m_Tool = trackerTool;
      this->m_World = world;
      this->m_TransformObserver->ObserveTransformEventsFrom( this->m_Tool );
      this->m_PositionMessage->SetDeviceName( toolName.c_str() );


      std::vector< igtl::ClientSocket::Pointer >::iterator it; 
      for (it = this->m_Sockets.begin(); it != this->m_Sockets.end(); ++it)
      {
        (*it)->CloseSocket();
        (*it)->Delete();
      }
      this->m_Sockets.clear();

      this->m_Destinations.clear();

      this->m_Destinations.insert( this->m_Destinations.begin(),
        destinations.begin(), destinations.end() );

      std::vector< std::pair<std::string, unsigned int> >::iterator destinationIt; 
      for ( destinationIt = destinations.begin(); destinationIt != destinations.end(); ++destinationIt)
      {
        igtl::ClientSocket::Pointer socket = igtl::ClientSocket::New(); 
        int r = socket->ConnectToServer( destinationIt->first.c_str() , (int)destinationIt->second );
        if (r != 0)
        {

          for (it = this->m_Sockets.begin(); it != this->m_Sockets.end(); ++it)
          {
            (*it)->CloseSocket();
            (*it)->Delete();
          }
          this->m_Sockets.clear();
          std::ostringstream msg;
          msg<<"Failed to connect to " <<  destinationIt->first << " port " <<  destinationIt->second;
          throw ExceptionWithMessage( msg.str() );          
        }
        this->m_Sockets.push_back(socket);
      }

    }

    void Execute(itk::Object *caller, const itk::EventObject & event)
    {
      const itk::Object * constCaller = caller;
      this->Execute( constCaller, event );
    }

    void Execute(const itk::Object *caller, const itk::EventObject & event)
    {

      //if no destinations, just return
      if( m_Sockets.empty() )
        return;

      //do something only for the correct tool
      if( this->m_Tool.GetPointer() == caller )
      {               //the tool transform has been updated, get it
        if( dynamic_cast<const igstk::TrackerToolTransformUpdateEvent  *>( &event) )
        {                 //request to get the transform               
          this->m_Tool->RequestComputeTransformTo( this->m_World );
          //check that we got it
          if ( this->m_TransformObserver->GotTransform() )
          {
            igstk::Transform transform = this->m_TransformObserver->GetTransform();
            igstk::Transform::VectorType t = transform.GetTranslation();
            igstk::Transform::VersorType r = transform.GetRotation();
            std::cout<<"Destinations:\n";
            for(unsigned int i=0; i<this->m_Destinations.size(); i++)
              std::cout<<"\t"<<this->m_Destinations[i].first<<":"<<this->m_Destinations[i].second<<"\n";
            std::cout<<"t:"<<t[0]<<"\t"<<t[1]<<"\t"<<t[2]<<"\n";
            std::cout<<"r:"<<r.GetX()<<"\t"<<r.GetY()<<"\t"<<r.GetZ()<<"\t"<<r.GetW()<<"\n";


            this->m_PositionMessage->SetPosition(t[0], t[1], t[2]);
            this->m_PositionMessage->SetQuaternion(r.GetX(), r.GetY(), r.GetZ(), r.GetW());
            this->m_PositionMessage->Pack();

            std::vector< igtl::ClientSocket::Pointer >::iterator it; 
            for (it = this->m_Sockets.begin(); it != this->m_Sockets.end(); ++it)
            {
              (*it)->Send(this->m_PositionMessage->GetPackPointer(), this->m_PositionMessage->GetPackSize());
            }

          }
        }
      }
    }

  private:
    std::string m_HostName;
    unsigned int m_PortNumber;  
    //we are interested in the tool location relative to the world's 
    //coordinate system
    igstk::SpatialObject::Pointer m_World;
    //TODO remove destinations vector;
    std::vector< std::pair<std::string, unsigned int> > m_Destinations;
    igstk::TransformObserver::Pointer m_TransformObserver; 
    igstk::TrackerTool::Pointer  m_Tool;

    // Sending tracking data to Slicer3
    std::vector< igtl::ClientSocket::Pointer > m_Sockets;
    igtl::PositionMessage::Pointer m_PositionMessage;
  };


  igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataType *
    GetTrackerConfiguration( std::string &configurationFileName) 
    throw ( ExceptionWithMessage );

  igstk::TrackerController::Pointer m_TrackerController;
};


#endif //__OIGTLinkTrackingBroadcaster_h
