#include "igstkTrackerConfiguration.h"
#include "igstkTrackerController.h"
#include "igstkPolarisVicraConfigurationXMLFileReader.h"
#include "igstkPolarisSpectraConfigurationXMLFileReader.h"
#include "igstkPolarisHybridConfigurationXMLFileReader.h"
#include "igstkAuroraConfigurationXMLFileReader.h"
#include "igstkMicronConfigurationXMLFileReader.h"
#include "igstkOIGTLinkTrackerConfigurationFileReader.h"
#include "igstkTransformObserver.h"

// For sending tracking data to OpenIGTLink compatible server 
#include "igtlOSUtil.h"
#include "igtlPositionMessage.h"
#include "igtlClientSocket.h"


/**
 * Observer for the event generated by 
 * TrackerConfigurationFileReader->RequestGetData() method.
 */
igstkObserverMacro( OIGTLinkTrackerConfiguration, 
                   igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataEvent, 
                   igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataPointerType )

/**
 * Observer for the TrackerController->RequestInitialize() failure.
 */
igstkObserverMacro( InitializeError, 
                   igstk::TrackerController::InitializeErrorEvent, 
                   std::string )


/**
 * Observer for the TrackerController->RequestGetNonReferenceToolList() 
 */
igstkObserverMacro( ToolList, 
                   igstk::TrackerController::RequestToolsEvent, 
                   igstk::TrackerController::ToolContainerType )

/**
 * Observer for the TrackerController->RequestGetTool() and  
 * TrackerController->RequestGetReferenceTool()
 */
igstkObserverMacro( Tool, 
                   igstk::TrackerController::RequestToolEvent, 
                   igstk::TrackerController::ToolEntryType )

/**
 * This class observes the TrackerToolTransformUpdateEvent for a specific tool.
 * It checks that the event is for the relevant tool and then gets the tool's
 * transform to its parent and prints it out.
 */
class ToolUpdatedObserver : public ::itk::Command
{
public:
  typedef  ToolUpdatedObserver    Self;
  typedef  ::itk::Command             Superclass;
  typedef  ::itk::SmartPointer<Self>  Pointer;
  itkNewMacro( Self );
protected:
  ToolUpdatedObserver() {
    this->m_TransformObserver = igstk::TransformObserver::New();
    this->m_PositionMessage = igtl::PositionMessage::New();
  }

  ~ToolUpdatedObserver() {
    std::vector< igtl::ClientSocket::Pointer >::iterator it; 
    for (it = this->m_Sockets.begin(); it != this->m_Sockets.end(); ++it)
    {
        (*it)->CloseSocket();
        (*it)->Delete();
    }
    this->m_Sockets.clear();

    this->m_PositionMessage->Delete();
  }

public:
 
  void Initialize( const std::string toolName, igstk::TrackerTool::Pointer trackerTool, 
                   std::vector< std::pair<std::string, unsigned int> > & destinations)
  {
    this->m_Tool = trackerTool;
    this->m_TransformObserver->ObserveTransformEventsFrom( this->m_Tool );
    this->m_PositionMessage->SetDeviceName( toolName.c_str() );


    std::vector< igtl::ClientSocket::Pointer >::iterator it; 
    for (it = this->m_Sockets.begin(); it != this->m_Sockets.end(); ++it)
    {
        (*it)->CloseSocket();
        (*it)->Delete();
    }
    this->m_Sockets.clear();


    this->m_Destinations.clear();
             //TODO: replace following line with creation of socket connections and
             //insert them into the m_Destinations vector
    this->m_Destinations.insert( this->m_Destinations.begin(),
                                 destinations.begin(), destinations.end() );

    std::vector< std::pair<std::string, unsigned int> >::iterator destinationIt; 
    for ( destinationIt = destinations.begin(); destinationIt != destinations.end(); ++destinationIt)
    {
       igtl::ClientSocket::Pointer socket = igtl::ClientSocket::New(); 
       int r = socket->ConnectToServer( destinationIt->first.c_str() , (int)destinationIt->second );
       if (r != 0)
       {
          std::ostringstream msg;
          msg<<"Failed to connect to " <<  destinationIt->first << " port " <<  destinationIt->second;
          throw std::exception( msg.str().c_str() );          
       }
       this->m_Sockets.push_back(socket);
    }
  }

  void Execute(itk::Object *caller, const itk::EventObject & event)
  {
    const itk::Object * constCaller = caller;
    this->Execute( constCaller, event );
  }

  void Execute(const itk::Object *caller, const itk::EventObject & event)
  {               //do something only for the correct tool
    if( this->m_Tool.GetPointer() == caller )
    {               //the tool transform has been updated, get it
      if( dynamic_cast<const igstk::TrackerToolTransformUpdateEvent  *>( &event) )
      {                 //request to get the transform               
        this->m_Tool->RequestGetTransformToParent();
                       //check that we got it
        if ( this->m_TransformObserver->GotTransform() )
        {
          igstk::Transform transform = this->m_TransformObserver->GetTransform();
          igstk::Transform::VectorType t = transform.GetTranslation();
          igstk::Transform::VersorType r = transform.GetRotation();
          std::cout<<"Destinations:\n";
          for(unsigned int i=0; i<this->m_Destinations.size(); i++)
            std::cout<<"\t"<<this->m_Destinations[i].first<<":"<<this->m_Destinations[i].second<<"\n";
          std::cout<<"t:"<<t[0]<<"\t"<<t[1]<<"\t"<<t[2]<<"\n";
          std::cout<<"r:"<<r.GetX()<<"\t"<<r.GetY()<<"\t"<<r.GetZ()<<"\t"<<r.GetW()<<"\n";


          this->m_PositionMessage->SetPosition(t[0], t[1], t[2]);
          this->m_PositionMessage->SetQuaternion(r.GetX(), r.GetY(), r.GetZ(), r.GetW());
          this->m_PositionMessage->Pack();

          std::vector< igtl::ClientSocket::Pointer >::iterator it; 
          for (it = this->m_Sockets.begin(); it != this->m_Sockets.end(); ++it)
          {
            (*it)->Send(this->m_PositionMessage->GetPackPointer(), this->m_PositionMessage->GetPackSize());
          }
        }
      }
    }
  }

private:
  std::string m_HostName;
  unsigned int m_PortNumber;  
       //TODO: change the m_Destinations vector to hold ClientSockets
  std::vector< std::pair<std::string, unsigned int> > m_Destinations;
  igstk::TransformObserver::Pointer m_TransformObserver; 
  igstk::TrackerTool::Pointer  m_Tool;

  // Sending tracking data to Slicer3
  std::vector< igtl::ClientSocket::Pointer > m_Sockets;
  igtl::PositionMessage::Pointer m_PositionMessage;
};


igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataType *
GetTrackerConfiguration( std::string &configurationFileName);


int main( int argc, char *argv[] )
{
  if( argc!=2 )
  {
    std::cerr<<"Usage: "<<argv[0];
    std::cerr<<"tracker_xml_configuration_file.\n";
    return EXIT_FAILURE;
  }

  try 
  {
    igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataType 
      *oigtLinkTrackerConfiguration = GetTrackerConfiguration( std::string( argv[1] ) );
    if( !oigtLinkTrackerConfiguration )
    {
      std::cerr<<"Unknown tracker type.\n";
      return EXIT_FAILURE;
    }
    //initialize the tracker controller, and setup the observers, start tracking
    igstk::TrackerController::Pointer trackerController = 
      igstk::TrackerController::New();

    InitializeErrorObserver::Pointer ieo = 
      InitializeErrorObserver::New();
    trackerController->AddObserver( igstk::TrackerController::InitializeErrorEvent(),
      ieo );
    trackerController->RequestInitialize( oigtLinkTrackerConfiguration->m_TrackerConfiguration );
    if( ieo->GotInitializeError() )
    {
      std::cerr<<ieo->GetInitializeError()<<"\n";
      return EXIT_FAILURE;
    }
    //make sure we don't have a reference and setup the observers
    ToolObserver::Pointer requestReferenceToolObserver = 
      ToolObserver::New();
    trackerController->AddObserver( igstk::TrackerController::RequestToolEvent(),
      requestReferenceToolObserver );
    trackerController->RequestGetReferenceTool();
    if( requestReferenceToolObserver->GotTool() )
    {
      std::cerr<<"You have set a dynamic reference frame.\n";
      std::cerr<<"The intention of this program is to output transformation data";
      std::cerr<<" relative to the tracker, please do not set reference.\n";
      return EXIT_FAILURE;
    }

    ToolListObserver::Pointer requestNonReferenceToolsObserver = 
      ToolListObserver::New();
    trackerController->AddObserver( igstk::TrackerController::RequestToolsEvent(),
      requestNonReferenceToolsObserver );

    trackerController->RequestGetNonReferenceToolList();
    if( requestNonReferenceToolsObserver->GotToolList() )
    {                   //get the tools from the tracker controller
      igstk::TrackerController::ToolContainerType toolContainer = 
        requestNonReferenceToolsObserver->GetToolList();
      igstk::TrackerController::ToolContainerType::iterator toolNamesAndToolsIt;
      //pair the tracker tools with the oigtlink data
      igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkDataType::iterator 
        toolNamesAndDestinationsIt, toolNamesAndDestinationsEnd;

      toolNamesAndDestinationsIt =
        oigtLinkTrackerConfiguration->m_ToolNamesAndConnections.begin();
      toolNamesAndDestinationsEnd =
        oigtLinkTrackerConfiguration->m_ToolNamesAndConnections.end();

      try 
      {
        for(; toolNamesAndDestinationsIt!=toolNamesAndDestinationsEnd; 
          toolNamesAndDestinationsIt++ )
        {
          toolNamesAndToolsIt = toolContainer.find( toolNamesAndDestinationsIt->first );   
          if( toolNamesAndToolsIt != toolContainer.end() )
          {
            ToolUpdatedObserver::Pointer updateObserver = ToolUpdatedObserver::New();
            updateObserver->Initialize( toolNamesAndDestinationsIt->first, toolNamesAndToolsIt->second, toolNamesAndDestinationsIt->second );          

            toolNamesAndToolsIt->second->AddObserver( igstk::TrackerToolTransformUpdateEvent(), 
              updateObserver );
          }
        }
      }
      catch (std::exception & e)
      {
        std::cerr << e.what() << endl;
        return EXIT_FAILURE;
      }

      trackerController->RequestStartTracking();

      while( 1 ) 
      {
        igstk::PulseGenerator::Sleep(10);
        igstk::PulseGenerator::CheckTimeouts();
      }

      return EXIT_SUCCESS;
    }
  }
  catch(std::exception &e)
  {
    std::cerr<<"Failed reading tracker configuration.\n";
    std::cerr<<e.what()<<"\n";
    return EXIT_FAILURE;
  }
}


igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataType 
* GetTrackerConfiguration( std::string &configurationFileName)
{
  const unsigned int NUM_TRACKER_TYPES = 5;
  igstk::TrackerConfigurationXMLFileReaderBase::Pointer 
    trackerCofigurationXMLReaders[NUM_TRACKER_TYPES];
  trackerCofigurationXMLReaders[0] = 
    igstk::PolarisVicraConfigurationXMLFileReader::New();
  trackerCofigurationXMLReaders[1] = 
    igstk::PolarisSpectraConfigurationXMLFileReader::New();
  trackerCofigurationXMLReaders[2] = 
    igstk::PolarisHybridConfigurationXMLFileReader::New();
  trackerCofigurationXMLReaders[3] = 
    igstk::AuroraConfigurationXMLFileReader::New();
  trackerCofigurationXMLReaders[4] = 
    igstk::MicronConfigurationXMLFileReader::New();


  igstk::OIGTLinkTrackerConfigurationFileReader::Pointer trackerConfigReader = 
    igstk::OIGTLinkTrackerConfigurationFileReader::New();

                //need to observe if the request read succeeds or fails
                //there is a third option that the read is invalid, if the
                //file name or xml reader weren't set
  igstk::OIGTLinkTrackerConfigurationFileReader::ReadFailSuccessObserver::Pointer 
    rfso = igstk::OIGTLinkTrackerConfigurationFileReader::ReadFailSuccessObserver::New();
  trackerConfigReader->AddObserver( igstk::OIGTLinkTrackerConfigurationFileReader::ReadSuccessEvent(),
                                    rfso );
  trackerConfigReader->AddObserver( igstk::OIGTLinkTrackerConfigurationFileReader::ReadFailureEvent(),
                                    rfso );
  trackerConfigReader->AddObserver( igstk::OIGTLinkTrackerConfigurationFileReader::UnexpectedTrackerTypeEvent(),
                                    rfso );

             //setting the file name and reader always succeeds so I don't
             //observe for success event
  trackerConfigReader->RequestSetFileName( configurationFileName );

  OIGTLinkTrackerConfigurationObserver::Pointer tco = 
    OIGTLinkTrackerConfigurationObserver::New();

  for( unsigned int i=0; i<NUM_TRACKER_TYPES; i++ )
  {
    //setting the xml reader always succeeds so I don't
    //observe the success event
    trackerConfigReader->RequestSetReader( trackerCofigurationXMLReaders[i] );  

    trackerConfigReader->RequestRead();


    if( rfso->GotUnexpectedTrackerType() )
    {
      rfso->Reset();
    }
    else if( rfso->GotFailure() && !rfso->GotUnexpectedTrackerType() )
    {
      throw std::exception( rfso->GetFailureMessage().c_str() );
    }
    else if( rfso->GotSuccess() )
    {
      //get the configuration data from the reader
      trackerConfigReader->AddObserver( 
        igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataEvent(),
        tco );
      trackerConfigReader->RequestGetData();

      if( tco->GotOIGTLinkTrackerConfiguration() )
      {
        igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataType *returnedResult =
          new igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataType();
        igstk::OIGTLinkTrackerConfigurationFileReader::OIGTLinkConfigurationDataType *
          result = tco->GetOIGTLinkTrackerConfiguration();

        returnedResult->m_TrackerConfiguration = result->m_TrackerConfiguration;
        returnedResult->m_ToolNamesAndConnections.insert( result->m_ToolNamesAndConnections.begin(), 
                                                          result->m_ToolNamesAndConnections.end() );
        return returnedResult;
      }
    }
  }
  return NULL;
}
