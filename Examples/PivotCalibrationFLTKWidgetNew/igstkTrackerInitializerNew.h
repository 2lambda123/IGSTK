/*=========================================================================

Program:   Image Guided Surgery Software Toolkit
Module:    $ $
Language:  C++
Date:      $ $
Version:   $ $

Copyright (c) ISC  Insight Software Consortium.  All rights reserved.
  See IGSTKCopyright.txt or http://www.igstk.org/copyright.htm for details.

This software is distributed WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.  See the above copyright notices for more information.

=========================================================================*/
#ifndef __igstkTrackerInitializerNew_h
#define __igstkTrackerInitializerNew_h

#include <FL/fl_ask.H>

#include "igstkSandboxConfigure.h"

#include "igstkTrackerConfigurationNew.h"

#include "igstkPolarisTracker.h"
#include "igstkPolarisTrackerTool.h"
#include "igstkAuroraTracker.h"
#include "igstkAuroraTrackerTool.h"
#include "igstkFlockOfBirdsTrackerNew.h"
#include "igstkFlockOfBirdsTrackerToolNew.h"

#ifdef IGSTKSandbox_USE_MicronTracker
#include "igstkMicronTracker.h"
#include "igstkMicronTrackerTool.h"
#endif /* IGSTKSandbox_USE_MicronTracker */

namespace igstk
{

/** \class TrackerInitializerNew
* 
* \brief A convenient class for setting up trackers.
*
* This class provides a generic API to talk to different trackers. 
* User needs to set the TrackerConfiguration first, after the 
* RequestInitializeTracker returns success. You can call
*     GetTracker()
*     GetNonReferenceToolList()
*     GetReferenceTool()
* to get pointers to the initialized tracker and tracker tool objects.
*/

class TrackerInitializerNew
{

private:
    /* Observe all tracking related errors, those generated by the tracker and
    the serial communication*/
    class TrackingErrorObserver : public itk::Command
    {
    public:
        typedef TrackingErrorObserver            Self;
        typedef ::itk::Command                   Superclass;
        typedef ::itk::SmartPointer<Self>        Pointer;
        typedef ::itk::SmartPointer<const Self>  ConstPointer;

        igstkNewMacro(Self)
        igstkTypeMacro(IGSTKErrorObserver, itk::Command)

        /*
        * When an error occurs in the tracker or serial communication component 
        * it will invoke this method with the appropriate error event object as 
        * a parameter. */
        void Execute(itk::Object *caller, const itk::EventObject & event);

        /*
        * When an error occurs in the tracker or serial communication component 
        * it will invoke this method with the appropriate error event object as 
        * a parameter. */
        void Execute(const itk::Object *caller, const itk::EventObject & event);

        /**
        * Clear the current error. */
        void ClearError();

        /**
        * If an error occurred in the tracker or serial communication this method
        * will return true. */
        bool Error();

    protected:

        /**
        * Construct an error observer for all the possible errors that occur in
        * the tracker and serial communication classes. */
        TrackingErrorObserver();

        virtual ~TrackingErrorObserver(){}

    private:

        /**
        *  member variables
        */
        bool                                m_ErrorOccured;
        std::map<std::string,std::string>   m_ErrorEvent2ErrorMessage;

        //purposely not implemented
        TrackingErrorObserver(const Self&);
        void operator=(const Self&);
    };

public:
  
  typedef TrackerConfigurationNew::TrackerType  TrackerType;

  typedef igstk::Logger                    LoggerType;

  TrackerInitializerNew( );

  void SetLogger(LoggerType* logger)
  {
     m_Logger = logger;
  }

  TrackerType GetTrackerType()
    {
    return m_TrackerType;
    }

  std::string GetTrackerTypeAsString();

  void SetTrackerConfiguration( TrackerConfigurationNew * config )
    {
    m_TrackerConfiguration = config;
    }

  int RequestInitializeTracker();
  
  itkGetStringMacro( ErrorMessage );
  
  igstk::Tracker::Pointer GetTracker()
    {
    return m_Tracker;
    }

  TrackingErrorObserver::Pointer GetErrorObserver()
    {
        return m_errorObserver;
    }

  std::vector< TrackerTool::Pointer > GetNonReferenceToolList()
    {
    return m_TrackerToolList;
    }

  int HasReferenceTool()
    {
    return m_HasReferenceTool;
    }

  TrackerTool::Pointer GetReferenceTool()
    {
    return m_ReferenceTool;
    }

  void StopAndCloseTracker()
    {
    m_Tracker->RequestStopTracking();
    m_Tracker->RequestClose();
    if ( m_TrackerType == TrackerConfigurationNew::Aurora || 
         m_TrackerType == TrackerConfigurationNew::Polaris || 
         m_TrackerType == TrackerConfigurationNew::FlockOfBirds)
      {
      m_Communication->CloseCommunication();
      }
    
    }


  virtual ~TrackerInitializerNew();

private:


  
  TrackerType                           m_TrackerType;

  Tracker::Pointer                      m_Tracker;
  std::vector< TrackerTool::Pointer >   m_TrackerToolList;
  bool                                  m_HasReferenceTool;
  TrackerTool::Pointer                  m_ReferenceTool;

  PolarisTracker::Pointer               m_PolarisTracker;
  AuroraTracker::Pointer                m_AuroraTracker;
  FlockOfBirdsTracker::Pointer          m_FlockOfBirdsTracker;

  SerialCommunication::Pointer          m_Communication;

  LoggerType                            *m_Logger;

  TrackingErrorObserver::Pointer        m_errorObserver;
  
  int InitializePolarisTracker();
  int InitializeAuroraTracker();
  int InitializeFlockOfBirdsTracker();

#ifdef IGSTKSandbox_USE_MicronTracker
  MicronTracker::Pointer                m_MicronTracker;
  int InitializeMicronTracker();
#endif /* IGSTKSandbox_USE_MicronTracker */
  

  TrackerConfigurationNew * m_TrackerConfiguration;
  
  std::string            m_ErrorMessage;

};

} // end of namespace
#endif
