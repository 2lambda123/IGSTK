/*=========================================================================

Program:   Image Guided Surgery Software Toolkit
Module:    $$
Language:  C++
Date:      $$
Version:   $$

Copyright (c) ISC  Insight Software Consortium.  All rights reserved.
  See IGSTKCopyright.txt or http://www.igstk.org/copyright.htm for details.

This software is distributed WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.  See the above copyright notices for more information.

=========================================================================*/

#include "igstkTrackerInitializerNew.h"
#include "itksys/SystemTools.hxx"
namespace igstk
{


/** Constructor: Initializes all internal variables. */
TrackerInitializerNew::TrackerInitializerNew()
{
    m_ErrorMessage = "";
    m_HasReferenceTool = 0;

    //create error observer
    this->m_ErrorObserver = IGSTKErrorObserver::New();
}

std::string TrackerInitializerNew::GetTrackerTypeAsString()
{
  switch( m_TrackerType )
  {
  case TrackerConfigurationNew::Polaris:
    return "Polaris"; break;
  case TrackerConfigurationNew::Aurora:
    return "Aurora"; break;
  case TrackerConfigurationNew::FlockOfBirds:
    return "FlockOfBirds"; break;
  case TrackerConfigurationNew::Micron:
    return "Micron"; break;
  default:
    return "Not Defined";
  }
}


/** -----------------------------------------------------------------
*  Stops and Disconnect a tracker. After disconnecting it, set the active tool
*  to the first available tool
*---------------------------------------------------------------------
*/
int TrackerInitializerNew::RequestStopAndDisconnectTracker()
{
    m_Tracker->RequestStopTracking();
    if ( this->m_ErrorObserver->Error() )
    {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
    }

    m_Tracker->RequestClose();
    if ( this->m_ErrorObserver->Error() )
    {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
    }

    if ( m_TrackerType == TrackerConfigurationNew::Aurora || 
         m_TrackerType == TrackerConfigurationNew::Polaris || 
         m_TrackerType == TrackerConfigurationNew::FlockOfBirds)
    {
        m_Communication->CloseCommunication();
        if ( this->m_ErrorObserver->Error() )
        {
          this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
          this->m_ErrorObserver->ClearError();
          std::cerr << m_ErrorMessage << "\n";
          return 0;
        }
    }
  return 1;
}

int TrackerInitializerNew::RequestInitializeTracker()
{
  if( m_TrackerConfiguration == NULL )
    {
    m_ErrorMessage = "Invalid configuration file";
    return 0;
    }

  m_TrackerType = m_TrackerConfiguration->GetTrackerType();

  if( m_TrackerType == TrackerConfigurationNew::Polaris )
    {
    return InitializePolarisTracker();
    }
  else if (m_TrackerType == TrackerConfigurationNew::Aurora)
    {
    return InitializeAuroraTracker();
    }
  else if (m_TrackerType == TrackerConfigurationNew::FlockOfBirds)
  {
    return InitializeFlockOfBirdsTracker();
  }
  else if (m_TrackerType == TrackerConfigurationNew::Micron)
    {
    #ifdef IGSTKSandbox_USE_MicronTracker
    return InitializeMicronTracker();
    #else
    m_ErrorMessage = 
      "Please configure IGSTKSandbox to use MicronTrakcer first\n";
    return 0;
    #endif /* IGSTKSandbox_USE_MicronTracker */
    
    }
  else
    {
    m_ErrorMessage = "Invalid tracker type";
    return 0;
    }

}

// FIXME: check error events listener
int TrackerInitializerNew::InitializePolarisTracker()
{
  NDITrackerConfiguration * trackerConfig = 
    m_TrackerConfiguration->GetNDITrackerConfiguration();
  
  m_Communication = SerialCommunication::New();

  //observe errors generated by the serial communication
  m_Communication->AddObserver( igstk::OpenPortErrorEvent(),
                                          this->m_ErrorObserver );
  m_Communication->AddObserver( igstk::ClosePortErrorEvent(),
                                          this->m_ErrorObserver );

  m_Communication->SetPortNumber( trackerConfig->m_COMPort );
  m_Communication->SetParity( SerialCommunication::NoParity );
  m_Communication->SetBaudRate(SerialCommunication::BaudRate115200);
  m_Communication->SetDataBits( SerialCommunication::DataBits8 );
  m_Communication->SetStopBits( SerialCommunication::StopBits1 );
  m_Communication->SetHardwareHandshake( SerialCommunication::HandshakeOff);

  m_Communication->OpenCommunication();
  if( this->m_ErrorObserver->Error() )
  {
    this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
    this->m_ErrorObserver->ClearError();
    std::cerr << m_ErrorMessage << "\n";
    return 0;
  }

  m_Tracker = m_PolarisTracker = PolarisTracker::New();

  //observe errors generated by the tracker
  m_Tracker->AddObserver( igstk::TrackerOpenErrorEvent(),
                                this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerInitializeErrorEvent(),
                                this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerStartTrackingErrorEvent(),
                                this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerStopTrackingErrorEvent(),
                                this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerUpdateStatusErrorEvent(),
                                this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerCloseErrorEvent(),
                                this->m_ErrorObserver );

  m_PolarisTracker->SetCommunication( m_Communication );
  m_PolarisTracker->RequestOpen();
  if( this->m_ErrorObserver->Error() )
    {
    this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
    this->m_ErrorObserver->ClearError();
    std::cerr << m_ErrorMessage << "\n";
    return 0;
    }

  m_TrackerToolList.clear();
  for( int i=0; i< trackerConfig->m_TrackerToolList.size(); i++ )
    {
    PolarisTrackerTool::Pointer tool = PolarisTrackerTool::New();
    NDITrackerToolConfiguration * toolConfig =
      trackerConfig->m_TrackerToolList[i];

    if( toolConfig->m_WiredTool)
      {
      tool->RequestSelectWiredTrackerTool();
      tool->RequestSetPortNumber( toolConfig->m_PortNumber );
      if ( toolConfig->m_HasSROM )
        {
        tool->RequestSetSROMFileName( toolConfig->m_SROMFile );
        }
      tool->SetCalibrationTransform( toolConfig->m_CalibrationTransform);
      tool->RequestConfigure();
      }
    else
      {
      tool->RequestSelectWirelessTrackerTool();
      tool->RequestSetSROMFileName( toolConfig->m_SROMFile );
      tool->SetCalibrationTransform( toolConfig->m_CalibrationTransform);
      tool->RequestConfigure();
      }
    
    tool->RequestAttachToTracker( m_PolarisTracker );
    if( this->m_ErrorObserver->Error() )
    {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
    }

    if( toolConfig->m_IsReference )
      {
      m_PolarisTracker->RequestSetReferenceTool( tool );
      m_ReferenceTool = tool;
      m_HasReferenceTool = 1;
      }
    else
      {
      TrackerTool::Pointer t = tool.GetPointer();
      m_TrackerToolList.push_back( t );
      }
    }

  m_Tracker->RequestSetFrequency( trackerConfig->m_Frequency );

  //start tracking
  m_Tracker->RequestStartTracking();
  if( this->m_ErrorObserver->Error() )
    {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
    }

  return 1;

}

// FIXME: check error events listener
int TrackerInitializerNew::InitializeAuroraTracker()
{
  NDITrackerConfiguration * trackerConfig = 
    m_TrackerConfiguration->GetNDITrackerConfiguration();

  m_Communication = SerialCommunication::New();

  //observe errors generated by the serial communication
  m_Communication->AddObserver( igstk::OpenPortErrorEvent(),
      this->m_ErrorObserver );
  m_Communication->AddObserver( igstk::ClosePortErrorEvent(),
      this->m_ErrorObserver );

  m_Communication->SetPortNumber( trackerConfig->m_COMPort );
  m_Communication->SetParity( SerialCommunication::NoParity );
  m_Communication->SetBaudRate(SerialCommunication::BaudRate115200);
  m_Communication->SetDataBits( SerialCommunication::DataBits8 );
  m_Communication->SetStopBits( SerialCommunication::StopBits1 );
  m_Communication->SetHardwareHandshake( SerialCommunication::HandshakeOff);
  
  m_Communication->OpenCommunication();
  if( this->m_ErrorObserver->Error() )
  {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
  }

  m_Tracker = m_AuroraTracker = AuroraTracker::New();

  //observe errors generated by the tracker
  m_Tracker->AddObserver( igstk::TrackerOpenErrorEvent(),
                                this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerInitializeErrorEvent(),
                                this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerStartTrackingErrorEvent(),
                                this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerStopTrackingErrorEvent(),
                                this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerUpdateStatusErrorEvent(),
                                this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerCloseErrorEvent(),
                                this->m_ErrorObserver );

  m_AuroraTracker->SetCommunication( m_Communication );
  m_AuroraTracker->RequestOpen();
  if( this->m_ErrorObserver->Error() )
  {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
  }

  m_TrackerToolList.clear();
  for ( int i=0; i< trackerConfig->m_TrackerToolList.size(); i++)
    {
    AuroraTrackerTool::Pointer tool = AuroraTrackerTool::New();
    NDITrackerToolConfiguration * toolConfig =
      trackerConfig->m_TrackerToolList[i];

    if( toolConfig->m_Is5DOF )
      {
      tool->RequestSelect5DOFTrackerTool();
      tool->RequestSetPortNumber( toolConfig->m_PortNumber );
      tool->RequestSetChannelNumber( toolConfig->m_ChannelNumber );
      if ( toolConfig->m_HasSROM )
        {
        tool->RequestSetSROMFileName( toolConfig->m_SROMFile );
        }
      tool->SetCalibrationTransform( toolConfig->m_CalibrationTransform);
      tool->RequestConfigure();
      }
    else // 6 DOF tool
      {
      tool->RequestSelect6DOFTrackerTool();
      tool->RequestSetPortNumber( toolConfig->m_PortNumber);
      if ( toolConfig->m_HasSROM )
        {
        tool->RequestSetSROMFileName( toolConfig->m_SROMFile );
        }
      tool->SetCalibrationTransform( toolConfig->m_CalibrationTransform);
      tool->RequestConfigure();
      }

    tool->RequestAttachToTracker( m_AuroraTracker );
    if( this->m_ErrorObserver->Error() )
    {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
    }

    if ( toolConfig->m_IsReference )
      {
      m_AuroraTracker->RequestSetReferenceTool( tool );
      m_ReferenceTool = tool;
      m_HasReferenceTool = 1;
      }
    else
      {
      TrackerTool::Pointer t = tool.GetPointer();
      m_TrackerToolList.push_back( t );
      }
    }

  m_Tracker->RequestSetFrequency( trackerConfig->m_Frequency );
  m_Tracker->RequestStartTracking();
  if( this->m_ErrorObserver->Error() )
  {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
  }

  return 1;
}

// FIXME: check error events listener
int TrackerInitializerNew::InitializeFlockOfBirdsTracker()
{
   AscensionTrackerConfiguration * trackerConfig = 
       m_TrackerConfiguration->GetAscensionTrackerConfiguration();

    m_Communication = SerialCommunication::New();

    //observe errors generated by the serial communication
    m_Communication->AddObserver( igstk::OpenPortErrorEvent(),
        this->m_ErrorObserver );
    m_Communication->AddObserver( igstk::ClosePortErrorEvent(),
        this->m_ErrorObserver );

    m_Communication->SetPortNumber( trackerConfig->m_COMPort );
    m_Communication->SetParity( SerialCommunication::NoParity );
    m_Communication->SetBaudRate(SerialCommunication::BaudRate115200);
    m_Communication->SetDataBits( SerialCommunication::DataBits8 );
    m_Communication->SetStopBits( SerialCommunication::StopBits1 );
    m_Communication->SetHardwareHandshake( SerialCommunication::HandshakeOff);

    m_Communication->OpenCommunication();
    if( this->m_ErrorObserver->Error() )
    {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
    }

    m_Tracker = m_FlockOfBirdsTracker = FlockOfBirdsTracker::New();

    //observe errors generated by the tracker
    m_Tracker->AddObserver( igstk::TrackerOpenErrorEvent(),
                                    this->m_ErrorObserver );
    m_Tracker->AddObserver( igstk::TrackerInitializeErrorEvent(),
                                    this->m_ErrorObserver );
    m_Tracker->AddObserver( igstk::TrackerStartTrackingErrorEvent(),
                                    this->m_ErrorObserver );
    m_Tracker->AddObserver( igstk::TrackerStopTrackingErrorEvent(),
                                    this->m_ErrorObserver );
    m_Tracker->AddObserver( igstk::TrackerUpdateStatusErrorEvent(),
                                    this->m_ErrorObserver );
    m_Tracker->AddObserver( igstk::TrackerCloseErrorEvent(),
                                    this->m_ErrorObserver );

    m_FlockOfBirdsTracker->SetCommunication( m_Communication );

    m_FlockOfBirdsTracker->RequestOpen();
    if( this->m_ErrorObserver->Error() )
    {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
    }

    m_TrackerToolList.clear();
    for ( int i=0; i< trackerConfig->m_TrackerToolList.size(); i++)
    {
        FlockOfBirdsTrackerTool::Pointer tool = FlockOfBirdsTrackerTool::New();
        AscensionTrackerToolConfiguration * toolConfig =
           trackerConfig->m_TrackerToolList[i];

        tool->RequestSetBirdName("bird0");

        tool->SetCalibrationTransform( toolConfig->m_CalibrationTransform );
        tool->RequestConfigure();

        tool->RequestAttachToTracker( m_FlockOfBirdsTracker );
        if( this->m_ErrorObserver->Error() )
        {
           this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
           this->m_ErrorObserver->ClearError();
           std::cerr << m_ErrorMessage << "\n";
           return 0;
        }

        if ( toolConfig->m_IsReference )
        {
        m_FlockOfBirdsTracker->RequestSetReferenceTool( tool );
        m_ReferenceTool = tool;
        m_HasReferenceTool = 1;
        }
        else
        {
        TrackerTool::Pointer t = tool.GetPointer();
        m_TrackerToolList.push_back( t );
        }
    }

    m_Tracker->RequestSetFrequency( trackerConfig->m_Frequency );

    m_Tracker->RequestStartTracking();
    if( this->m_ErrorObserver->Error() )
    {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
    }

    return 1;
}

#ifdef IGSTKSandbox_USE_MicronTracker
// FIXME: check error events listener
int TrackerInitializerNew::InitializeMicronTracker()
{
  MicronTrackerConfiguration * trackerConfig = 
    m_TrackerConfiguration->GetMicronTrackerConfiguration();

  m_Tracker = m_MicronTracker = MicronTracker::New();

  //observe errors generated by the tracker
  m_Tracker->AddObserver( igstk::TrackerOpenErrorEvent(),
                                    this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerInitializeErrorEvent(),
                                    this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerStartTrackingErrorEvent(),
                                    this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerStopTrackingErrorEvent(),
                                    this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerUpdateStatusErrorEvent(),
                                    this->m_ErrorObserver );
  m_Tracker->AddObserver( igstk::TrackerCloseErrorEvent(),
                                    this->m_ErrorObserver );
  
  m_MicronTracker->SetCameraCalibrationFilesDirectory( 
    trackerConfig->m_CameraCalibrationFileDirectory );

  m_MicronTracker->SetInitializationFile( 
    trackerConfig->m_InitializationFile );

  m_MicronTracker->SetMarkerTemplatesDirectory( 
    trackerConfig->m_TemplatesDirectory );

  m_MicronTracker->RequestOpen();
  if( this->m_ErrorObserver->Error() )
  {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
  }

  m_TrackerToolList.clear();
  for ( int i=0; i< trackerConfig->m_TrackerToolList.size(); i++)
    {
    MicronTrackerTool::Pointer tool = MicronTrackerTool::New();
    MicronTrackerToolConfiguration * toolConfig = 
      trackerConfig->m_TrackerToolList[i];

    tool->RequestSetMarkerName( toolConfig->m_MarkerName );
    tool->SetCalibrationTransform( toolConfig->m_CalibrationTransform );
    tool->RequestConfigure();

    tool->RequestAttachToTracker( m_MicronTracker );
    if( this->m_ErrorObserver->Error() )
    {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
    }

    if( toolConfig->m_IsReference )
      {
      m_MicronTracker->RequestSetReferenceTool( tool );
      m_ReferenceTool = tool;
      m_HasReferenceTool = 1;
      }
    else
      {
      TrackerTool::Pointer t = tool.GetPointer();
      m_TrackerToolList.push_back( t );
      }
    }

  m_Tracker->RequestSetFrequency( trackerConfig->m_Frequency );
  m_Tracker->RequestStartTracking();
  if( this->m_ErrorObserver->Error() )
  {
        this->m_ErrorObserver->GetErrorMessage(m_ErrorMessage);
        this->m_ErrorObserver->ClearError();
        std::cerr << m_ErrorMessage << "\n";
        return 0;
  }

  return 1;

}

#endif /* IGSTKSandbox_USE_MicronTracker */

/** Destructor */
TrackerInitializerNew::~TrackerInitializerNew()
{
  if (m_TrackerConfiguration)
    {
    delete m_TrackerConfiguration;
    }

}

} // end of namespace
